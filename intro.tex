\section{Introduction}

The growing complexity of higher education institutions means an increasing reliance on technology, in particular, software. Most institutions rely heavily on databases and management platforms, such as Banner \cite{BannerWebsite}, to manage the complexity. Similarly, learning management systems such as Moodle \cite{MoodleWebsite} and Blackboard \cite{BlackboardWebsite} improve the educational experience of students and faculty by facilitating and automating common tasks such as grading and distributing information to classes. Some of the software is open source (e.g., Moodle), which means the software itself is free, but the customization and support of the software costs the institution. Proprietary software typically has a combination of an initial purchase cost, a maintenance cost, and a multi-year contract. While the software can receive good support from the developers and institution-specific customization as-needed, the annual costs can creep into the thousands of dollars per application. According to a 2015 report about higher education spending, it is estimated that higher education institutions spend on average 4.2\% of their entire budget on information technology alone \cite{CDSBenchmarkReport}. 

Most purchasable software is built to meet the general needs of managing higher education, such as course registration and scheduling, but do not handle the nuanced difference that exist at every institution. For example, some institutions operate on a typical semester calendar consisting of a Fall, Spring, and Summer term. Other institutions may operate on a quarterly calendar, or they may have other terms such as a January short-term, multiple summer terms, online courses without specific start and end dates, or not operate on a calendar system at all. These institution-specific modifications are supported by software developers through ``additional services'' they provide. In other words, they are going to cost the institution on top of the base cost of the software.

Worse yet, each institution is unique in its needs, and sometimes the software simply doesn't exist. For example, there are nine work colleges in the United States \cite{WCCMembers, Ecclesia}. A work college requires every student to be employed while attending, and student employment is considered a part of the institution's academic mission. Given there are only nine work colleges, there isn't a market for the creation of large-scale software to support work colleges. However, there is a lot of need for software to manage a work college, such as tracking student employment, time-sheets for clocking hours, reporting back to the federal government and other funding sources, and evaluating student and supervisor performance, to name a few. Using existing software sometimes solves parts of the institutions needs (e.g., there's plenty of time-sheet solutions out there already), but often is missing key features that are institution-specific. Again, custom software and modifications to existing software is expensive and adds to the cost of managing the institution. In the case of work colleges, which tend to be smaller institutions, this cost is particularly prohibitive. 

However, an institution's unique needs can be met by a team of students crafting custom, institution-specific software. Instead of hiring an entire software engineering team (which would be quite expensive), a faculty or staff member can serve as a project manager to a team of students, guiding them in the development of software. The institution can avoid the high cost of software and maintenance, but still get applications that are tailored specifically to meet their needs. 

There are a plethora of examples of students creating real-world (i.e., software that is eventually used by the product owner to do their business) software in courses \cite{coursevsproject, tadayon2004software}, capstone experiences \cite{keogh2007scalable, capstone}, and internships outside of the institution \cite{rochesterfirstundergradsoftwareteam}. Kaminar \cite{kaminer_2014} summarizes a few instances where students developing software that was eventually adopted by the institution. These adoptions occurred organically however, and were typically one-off ventures. To our knowledge, no examples were found of institutions hiring students to develop custom software solutions in a multi-semester, internship model, making this program the first of its kind. 

One of the primary benefits of a program such as this is that the students gain valuable experience, preparing them for the software engineering industry after graduation. The students learn numerous technical skills \cite{hardskills}, such as specific programming and markup languages, software engineering principles, libraries, frameworks, web development, MVC, and more. Students also learn a number of valuable soft skills, such as critical thinking, leadership, project and time management, teamwork, and problem solving; skills deemed valuable for new graduates to have by employers \cite{lavy2013soft}. Previous work has shown that these benefits are easily obtainable through the development of real-world applications, regardless of the setting with which the application is developed (course, capstone, internship, etc.) \cite{heggen2018hiring, liu2005enriching, alzamil2005towards}.

This paper describes a the framework for a program which blends the best parts of a software engineering course, a capstone experience, and an external experience like an internship. Through a work-study program, students are employed by the Computer Science department to develop software for the institution. Teams of students start in the summer, working approximately 400 hours under the supervision of a faculty member, where they are trained on the software engineering principles and apply them to in-progress projects or new ones. The projects are proposed by the campus community (a.k.a. the product owner) and are then selected by the team. These projects are often tools requested by the product owner to help them complete their daily work, and thus, the software becomes an integral part of their job. Students intend to finish the beta version of the product by the end of summer. During the subsequent academic year (i.e., Fall and Spring terms), the students work an additional 300 or more hours, where they maintain the software, implementing new feature requests, fixing bugs, and performing customer support for their applications. 

The remainder of this paper is organized as follows: Section 2 describes the framework for employing students as software developers for an academic institution; Section 3 describes the software, how it is selected, and provides examples of software already created; Section 4 presents results from surveys issued to product owners about the effectiveness of the solutions developed by the students; and Section 5 concludes the paper with closing remarks. 
