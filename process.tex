\section{Our Existing Software Engineering Framework}

Over these last six years, an evolving process was created that informs the current framework presented here. Following best practices in lean thinking, the current framework is regularly evaluated and modified to met the team's current needs. Thus, the framework presented in this section represents the current state and has been generalized as much as possible, but will certainly continue to change as the needs of the team evolve.

The team of students follow Agile principles \cite{agilemanifesto} using a modified version of Scrum \cite{thescrumguide}. The Scrum methodology identifies three key roles in a software development team: product owner, Scrum Master, and the development team. The product owner is the customer who made the software request and determines the vision and purpose of the software product. All work must be approved by the product owner before it is considered complete. The Scrum Master is typically a full-time employee of the college, managing the development team and the backlog of work, ensuring focus is maintained on the most important features of the application. Finally, the development team in this framework consists of undergraduate students who are ``structured and empowered by the organization to organize and manage their own work'' \cite{thescrumguide}. Scrum theory provides an iterative, yet incremental approach to cut down on risks and enhance the predictability of the project for the product owner.

Scrum also prescribes four events in the software engineering process: sprint planning, the sprint, sprint review, and sprint retrospective. These four events are implemented differently in the framework depending on the term. In the summer, the team follows a more traditional Scrum model with a product backlog and work in progress determined during spring planning, daily Scrum meetings occurring during the sprint, and a Sprint Review and Retrospective happening every two to three weeks before starting the next cycle. In a typical regular term (i.e., a Fall and Spring term consisting of 16 weeks each), the Scrum time-frame is stretched out due to students working only 10 hours per week instead of 40 hours per week. Daily Scrums become weekly, and Sprints take four to six weeks. Because the regular term is significantly less hours worked, we often save new systems and major features for the upcoming summer term, while smaller features and bug fixes happen during the regular term.

The next section will first describe our framework during the Summer Internship Phase, followed by a the framework during the Fall and Spring terms, coined the Maintenance and Customer Support Phase.

\subsection{The Summer Internship Phase}
Starting in the summer term, students are hired into the SSDT based on a few metrics, including grades in key classes, their ability to work well with others (namely, pair programming \cite{2002PairProgramming}, and the perceived value they will attain from participating in the program (i.e., the strongest CS students are not always selected, as they may not benefit as much from the program), to name a few.

A typical summer operates much like an internship, where students are employed for 40 hours per week for 8-10 weeks, resulting in up to 400 hours of software engineering experience. Their expectations mirror an internship in many ways: they are expected to be punctual, productive throughout the day, and regularly report their progress to supervisors. Each summer consists of six to ten students managed by one faculty and two staff (the leadership team). The students work in pairs as they design interfaces and develop code. Very rarely will a student have been explicitly trained on software engineering principles such as Agile methodologies, Model-View-Controller (MVC) or similar frameworks, or large-scale application development, prior to joining the team.

A key skill gained by our students very early in the summer internship is the ability to translate customer's needs into usable software (i.e., requirements gathering and design). Students begin by paper prototyping \cite{2003paperPrototype} a design of the application. This design process consists of many iterations of interfaces drawn on paper. Designs are critiqued and modified until there is a group consensus to move forward. This avoids the students spending significant hours writing code that doesn’t match the team’s understanding of the application or the product owner’s needs. After paper prototyping, the students begin to construct the models that support their prototype. As a group, they propose the underlying data structures of the application and the relationships between parts of the model. This process provides students with a better understanding of the model when they begin implementing their prototype, reducing confusion about how data is stored and retrieved. Having the front-end design and data model in place, the students begin building the application. Students are first given a virtual machine (VM) to develop on, which mirrors the production environment, but also requiring them to learn some basic Linux commands and usage (again, a new skill for most). Working from a template, pairs of students begin construction from a common git repository with a pre-loaded template.

Throughout the process described above, students meet every morning for a daily Scrum. It is encouraged and expected that students will have lots of questions early in the process. In fact, most of the training happens as a result of a student asking a question, since the team does not spend significant time doing formal training for the program. As the summer progresses, the leadership team begins expecting the students to ask each other for help first. This promotes sharing of knowledge among teams, as pairs begin to solve similar problems that others have already seen, and can help each other from making the same mistakes. To maintain organization and visibility about what features each team is working on, we leverage Kanban boards \cite{anderson2010kanban}. Applying the Kanban model in tandem with the Scrum framework aids in managing the overall flow of the project.

As interfaces get close to being completed, the pairs begin conducting a usability test \cite{usabilitytesting} to test interactions. The pair will run the usability test first with another team who has not used their interface, then the leadership team, and lastly with the product owner to get their final approval of the implementation. Then, the students’ code gets tested for security, coding standards, accessibility guidelines, and bugs before being integrated into the production environment by the leadership team.

Ideally, by the end of summer, the product is delivered to the customer fully implemented. As this is not always the case, constant communication with the product owner as well as clearly setting expectations very early alleviates issues with surprises about delays in deployment. Any features that aren't completed in the summer term migrate to the regular term, after critical bugs are resolved.

\subsection{The Maintenance and Customer Support Phase}
When the Fall term begins, the team shifts to working 10 hours per week, as the students are now also responsible for attending classes. As expected, the productivity of the students reduces dramatically in the regular terms. The framework takes this into consideration. The team shifts its focus to maintaining existing software and responding to customer needs (e.g., bug fixes or small feature requests) before attempting to build new interfaces. Students gain valuable experience maintaining their software after deployment, a skill rarely taught in software engineering courses after projects are ``completed'' and delivered to customers.

Similar to summer, the Kanban board is instrumental to keeping the team organized and aware of each others' work, particularly since the students' schedules become more spread out. Students check the Kanban wall for new issues, claim them, and keep record of their progress on the wall. This flow helps developers visualize their progress and estimate their time, which is essential given they only have 10 hours per week to work. When the issue is resolved and tested, a pull request is created and reviewed by the leadership team.
