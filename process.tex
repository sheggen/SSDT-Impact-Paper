\section{Software Engineering Process}

%CUT this is process, which is the next section:
The recreation of the web application presented the student programmers with the opportunity to learn how to reevaluate the needs of the consumer, while also getting the chance to practice all the skills needed to rebuild an existing application from the ground up inside of a specified time frame. The rebuild process started with the student programmers sitting down and identifying all of the inefficiencies and bugs found in the original web application, from the standpoint of both the user and the programmer. Once all of the major issues were addressed, the next step was to go through several iterations of paper prototyping to redesign the some of the major user interfaces of the web application. The student programmers needed to learn how to consider how users could interact with any given user interface in every possible way. The iterations of paper prototyping also helped the student programmers transition into building the database schema, because paper prototyping allowed them to develop a sense of wh at data would be necessary to populate the user interfaces. After the conclusion of this step, the student programmers set off in pair programming teams to begin the reconstruction of the original web application. The student programmers learned and followed Agile principles using a modified version of Scrum to carry out their programming duties, with the end goal of creating a working demo of the web application by the end of the summer. At the conclusion of the summer, the student programmers demoed their work to the Labor Office staff and received incredibly positive feedback. The Labor Office staff was relieved to see how the new web application took care of almost all of their needs, and even handled issues they did not realize could be automated. Aside from a few modifications and features the Labor Office staff wanted in future iterations, the demo was successful. Since the initial demo, the student programmers have been following the Agile methodology to build out the new web application. Every new user interface or modification to an existing piece of the software goes through rounds of design, development, testing, and live demos to ensure it meets the standards the team has set. The software is currently very near completion, and should be deployed soon after the submission of this research paper.


\section{Our Software Engineering Model}
%TODO Keep here or move?  Over a five year period, a process was created and refined that informed the current framework, which is designed for employing students as software developers for the purpose of developing applications for an academic institution. 

Following best practices in lean thinking, the current framework has  constantly being evaluated, redesigned, and optimized over the course of five years. Thus, the framework presented in this section represents its current state, but has been generalized as much as possible. It will certainly change as needs of the team and the institution evolve. Figure~\ref{fig:framework} illustrates the framework, including both the summer and regular term, each of which have different structures as described in the remainder of this.

%%TODO NEW TABLE

The team of students follow Agile principles \cite{agilemanifesto} using a modified version of Scrum \cite{thescrumguide}. The Scrum methodology dictates that there are three key roles in which all those involved with the development of a software fall under: product owner, Scrum Master, and the development team. The product owner, in relation to the team, is the customer who makes a software request and determine the vision and purpose of the software product. Newly added features, fixed bugs, and completed software must be approved and accepted by the product owner before it is considered complete. The Scrum Master is charged with the responsibility of facilitating the development team and communicating the needs of the product owner. The Scrum Master supports and promotes the development team and ensures that the team understands and follows Scrum principles. In our framework, the Scrum Master is not typically a student, unless they have been on the team a significant number of years and can handle the responsibility of guiding the development of the software. Typically, the Scrum Master is a full-time employee of the college (i.e., faculty or staff) who also acts as the team's supervisor. Finally, the development team in this framework consists of undergraduate students who are ``structured and empowered by the organization to organize and manage their own work'' \cite{thescrumguide}. Following Scrum theory provides an iterative, yet incremental approach to cut down on risks and enhance the predictability of the project for the product owner and the development team.

Scrum also prescribes four events in the software engineering process: sprint planning, the sprint, sprint review, and sprint retrospective. These four events are implemented differently in the framework depending on the term.  In the summer, the team follows a more traditional Scrum model with a product backlog and work in progress determined during spring planning, daily Scrum meetings occurring during the sprint, and a Sprint Review and Retrospective happening every two to three weeks before starting the next cycle. In the regular term (i.e., a Fall and Spring term consisting of 16 weeks each), the Scrum time-frame is stretched out due to students working only 10 hours per week instead of 40 hours per week. Daily Scrums become weekly, and Sprints take four to six weeks. Because the regular term is significantly less hours worked, we often save new systems and major features for the upcoming summer term, while smaller features and bug fixes happen during the regular term.

This next section will first describe our framework during the summer term, coined the Summer Internship Phase. Then, the following section will describe the framework during the fall and spring terms, coined the Maintenance and Customer Support Phase.

\subsection{The Summer Internship Phase}
Starting in the summer term, students are hired into the Student Software Development Team (SSDT). Students apply in the previous spring term through an open application process. The students are then hired based on a few metrics, including grades in key classes, such as the CS1 course; their ability to work well with others (based on their interactions with other students in classes, which follow a team-based \cite{2002PairProgramming}, active learning pedagogy \cite{2012Pogil}; and the perceived value they will attain from participating in the program (i.e., the best computer science students are not always selected, as they may not benefit as much from the program), to name a few.

A typical summer operates much like an internship outside of an academic institution. Students are employed for 40 hours per week for eight to ten weeks, resulting in up to 400 hours of software engineering experience just in the summer alone. During this time, their expectations mirror an internship in many ways, in that they are expected to be punctual, be productive throughout the day, and report back to supervisors of their progress. Each summer consists of six to ten students managed by 2 supervisors (one faculty, one staff). The students typically work in pairs as they design interfaces and develop code.

Early in the summer, students have varying skill levels, but mostly all are untrained on any software engineering principles. All student recruited into the program will have passed the CS1 course, but otherwise, their experience varies. For example, rising seniors will have completed CS2 and maybe a few upper level CS courses, while rising sophomores may have only had CS1. Very rarely will a student have been explicitly trained on software engineering principles, such as Agile methodologies, Model-View-Controller (MVC) or similar frameworks, or large-scale application development.

Contrary to what might seem obvious, the students do not spend a significant amount of time in ``training.'' Instead, we follow a ``just-in-time'' learning principle, where the students are given only as much theory and knowledge about software engineering as is needed to begin the task at hand. For example, one of the first skills students must develop is the ability to work in a version control system, in our case, Git. Students are walked through Git basics, such as how to clone the repository, make commits, and issue pull requests, and then they are given their first issue from the issue queue. Their first issue is often selected very intentionally by the supervisors; for example, finding and fixing a typo in a README of one of the repositories. This gives them the confidence to make a change and issue a pull request to the repository owner, without the fear of breaking any system.

A key skill needed and learned by our students very early in the summer internship is the ability to translate customer's needs into usable software (i.e., design). The first step in designing new software is to paper prototype \cite{2003paperPrototype} the software before spending significant hours writing code. This design process consists of many iterations of interfaces on paper; designs are critiqued and modified until there is a group consensus to move forward. Early the beginning of this process, when students are still very new to the idea, the supervising faculty member will act as the "driver," meaning they "click-through" the interface drawn on paper by the students, while those who designed the prototype will move pieces of paper, representing new parts of the interface, to act out its functionality. The first draft typically acts as an eye-opener for the students; the driver will find many flaws and functionalities that their designs are missing. These design mistakes are noted, and the students return to the drawing board to build another version on paper. After multiple iterations, review sessions, and the group approves of the interfaces, the product owner is invited to demo the entire paper prototyped application. Once the product owner's feedback is recorded and taken into account when making the next version. When the interface is finally approved, the paper prototypes are video recorded for later reference (i.e., during coding).

After paper prototyping is complete, the students review their interfaces and begin to construct the database supporting their prototypes. Again, many of the students have never taken a database design course, requiring more just-in-time training. As a group, they participate in a model building session in which they propose the underlying data structures of the application and the relationships between parts of the model. Multiple design iterations along with guidance from the supervisors lead to the students designing a working database which will support their paper prototypes. One of the key benefits of the students going through this process is they have a much better understanding of the models when they begin implementing their prototypes, reducing confusion about how data is saved and retrieved.

Having a design in place, plus an understanding of the data model, the students are ready to begin building the application. Students are first given a virtual machine (VM) to develop on, which mirrors the production environment, but also requiring them to learn some basic Linux commands and usage (again, a skill they may not have learned in their courses yet). In pairs, students clone a bare-bones template for the application, with only as much code written for them as is necessary to begin writing code. For example, a main page may be constructed, with minimal content in it, and a basic query to the database to fill it with some dynamic content. From there, the student pairs must replicate the structure of the view and controller into their own interface.

Throughout the process described above, students meet every morning for a daily Scrum. It is encouraged and expected that students will have plenty of questions early on in the summer internship. In fact, most of the just-in-time learning described above happens as a result of a student asking a question. As the summer progresses and the students' capabilities improve, the questions become more technical in nature. In these morning Scrum meetings, demonstrations may also occur, as interfaces need group review. The students are encouraged to present their incomplete interfaces early, so they can get feedback about components they may impact future code. Lastly, code is often brought up to demonstrate good and bad coding practices, and correct them before the problems become too large to handle, to avoid large amounts of refactoring. The intention is to catch flaws, misconceptions, and problems early on to keep our programs agile and easily adaptable.

As the summer progresses, the supervisors take an increasingly hands-off approach, expecting the students to ask each other for help first. This promotes sharing of knowledge among teams, as pairs begin to solve problems that others have already solved (or those similar), and know some of the pitfalls to avoid. To maintain organization and visibility about what features each team is working on, we leverage Kanban boards, or Work in Progress (WIP) boards \cite{anderson2010kanban}. Applying the Kanban model in tandem with the Scrum framework aids in managing the overall flow of the project. The Kanban model prioritizes three essential principles: visualize what will be done today, reduce the amount of work that is in progress, and properly manage the flow. Kanban encourages continued cooperation and creates an environment that promotes ongoing learning by describing the optimal team workflow. The blending of Kanban and Scrum is also known as Scrumban \cite{ladas2009scrumban}. Figure \ref{kanban} shows the most recent iteration of our Kanban board (which has changed many times as the team finds ways to improve its usefulness).
%seems like this board needs to be explained more for it to be here -kat 10/28/19

Another important tactic in promoting the sharing of knowledge involves rotating teams. The team lead and supervising faculty member conduct a meeting a few weeks into the summer term to evaluate each pair's performance. They evaluate each developer's strengths and weaknesses, then redistribute the teams. Typically one developer stays on the interface they were already working on developing, and gain a new partner who is new to the interface. Shuffling the pairs helps students be flexible, learn to collaborate with others, and most importantly, reveals the importance of well-documented code and following coding standards adopted by the team. It also encourages the students to be able to explain their progress, clearly articulate their goals, and know exactly what their code does as they explain it to their new partner.

As interfaces get close to being completed, the pairs are expected to conduct a usability test \cite{usabilitytesting} to ensure that their interface is user-friendly. The pair will run the usability test first with another team who has not used their interface prior. The hosting team provides a set of tasks or scenarios to complete, then observe the user. Usability tests showcase previously unseen faults or unconsidered scenarios in their interfaces thus far. For example, during development, teams will commonly only test the expected use case. The usability test might reveal that there is another set of operations that the user can do which causes a crash. After fixing these new bugs or improvements, they will conduct another usability test, typically with the supervisors as the driver. It is expected that there will be less (but rarely none) new bugs or usability problems to fix. A third (or more) usability test is then conducted with the product owner, to get their final approval of the implementation.

Ideally, by the end of summer, the product is delivered to the customer fully implemented. As this is not always the case, constant communication with the product owner as well as clearly setting expectations very early alleviate issues with surprises about delays in deployment. Any features that aren't completed in the summer term become issues for the team during the regular term, after critical bugs are resolved (more on this in the next section). The team reflects on its progress, what worked well and what did not. Each interface is thoroughly documented of its state and what is left to be done so the next set of developers who take it on will have a good idea of what direction to go in.

\subsection{The Maintenance and Customer Support Phase}
As the Fall term begins, the team shifts from working 40 hours to 10 hours per week, as the students are now also responsible for attending classes and other academic responsibilities. As expected, the productivity of the students shifts dramatically between summer and the regular terms. The framework takes this into consideration. Whereas summer terms focus heavily on designing new, major features or entire software systems, the regular fall and spring terms focus more on maintaining existing software and responding to customer needs (e.g., bug fixes or small feature requests). The expectation is that the regular term provides students with the valuable experience of having to maintain their software after deployment, a skill rarely taught in software engineering courses after projects are ``completed'' and delivered to customers.

Students meet with the supervisors at the beginning of the Fall term to schedule their hours around their courses and other academic responsibilities, with the goal of ensuring no student is working alone for extended periods of time. Students who work alone for too much of their time develop bad coding habits without their code being reviewed frequently, leading to wasted effort as the code they create doesn't make it to the final product. Similarly, students working alone often make poor design and usability choices as they implement, leading to useless software. Lastly, if the student gets stuck on a problem, there is no one there to brainstorm solutions with them. The supervisor, in our case a faculty also teaching courses, isn't as available to assist the students as quickly, meaning they must rely on each other to get unstuck more-so than during the summer. It is crucial that students work with other students to fix bugs and solve problems in order to maintain steady progress in development.

Work duties are mostly determined by the users as they encounter bugs, and the product owner, as they start thinking of new features they want in their software. Customers report bugs or new feature requests via email to the supervisors, who evaluate the priority and difficulty of the issue. The issue is then added to the issue queue for that application. If the issue is urgent (e.g., causing crashes or rendering an interface unusable), the issue is taken by the first student that is available (i.e., the next one to come to work). In some cases, the bug warrants one or more of the supervisors to work on the issue immediately. For non-critical issues, the issue is discussed in the weekly scrum meeting and added to a team's work in progress, or left in the issue queue if it's not considered the most pressing issue for that week.

% Back to the kanban board...
Similar to summer, the Kanban board is instrumental to keeping the team organized and aware of each others' work, particularly since the students' schedules become more spread out. Students check the Kanban wall for new issues, claim them, and keep record of their progress on the wall. This flow helps developers visualize their progress and estimate their time, which is essential given they only have 10 hours per week to work. When the issue is resolved and tested by multiple student developers, a pull request is issued. Pull requests are reviewed by the supervisors, and returned if there are errors or standards not followed. An accepted pull request must pass our guidelines for coding structure, naming conventions, security, and best practices. The supervisors are responsible for the last mile; integrating the feature into the production environment. Sometimes bugs are found during integration, which are pushed back down into the repository, requiring all developers to pull in these changes (as well as the new feature itself) to synchronize the everyone's local environments.



\section{A Response to COVID-19}
Though the first case of the virus was traced back to November 2019 \cite, worldwide awareness of the novel coronavirus disease, abbreviated as COVID-19, began to swell in the early months of 2020. As the number of cases grew internationally, organizations such as the Center for Disease Control (CDC) began to publicize methods to prevent the spread of the virus which included self-quarantining for at least two weeks if exhibiting symptoms or diagnosed. However, despite the "work" that was done to quell the disease, on March 11th, 2020 the World Health Organization, or WHO, officially classified the COVID-19 outbreak as a pandemic. \cite Following this declaration businesses, educational institutions, municipalities, etc. began close their physical locations an opt-in to a remote working model en masse. This, consequently, included our institution that "hosts" the SSDT, which made the decision to close its campus within the week of the WHO's announcement.

Following this closure, the SSDT had to quickly adapt its model to this new state of the work environment. These adjustments were made at a critical time for the team as this major change coincided with a soft-release date for the current software project. The first step in this process was cleaning up our application's repository and prioritizing all of the issues that remained; here the Scrum Master determined which issues were not only the most necessary but also feasible to complete given the new circumstances. The next step consisted of the Scrum Master, the Team Lead, and the "Project Manager" doing a thorough walkthrough of the current application; this was done so that new issues could be added to the queue for the students to tackle. The final and most important step was deciding which tools the team would use that would most closely resemble the workflow that existed while on campus.  Ultimately, it was decided to use a business communication platform, a colloborative code editor, and wireframing tool; more detailed explanations of how these tools were used are featured below. One of the many considerations that had to be acknowledged during this process is that multiples students no longer had the luxury of be in labor-oriented setting with little to no distractions. Many students moved back in with their families who were also home more often during this time while other students had to balance their parenting duties and work schedules.

\subsection{An Adjusted Process}
Constant and consistent communication was of the utmost importance.The SSDT was already utilizing a team communication platform for all of its internal communication and thus, it was decided to continue with a heavier reliance of this application. The student programmers were required to give a DDS, (Did, Doing, Stuck) daily detailing what they completed that day, what they will complete on their next work day, and if they are stuck on anything. The faculty leader and staff members would check these updates at the end of the workday to determine progress and ensure students are not stuck for an extended amount of time. As previously mentioned, the entire team would meet daily during the Summer Internship Phase for a Scrum meeting. Fortunately, the communication platform offered video calling capabilities allowing the team to continue these meetings as they did the previous Summer. Video calling also allowed the faculty member to provide ``just-in-time" training to the newest students of the team. The platform also supported screen-sharing and virtual drawing which also assisted conveying concepts and demonstrating coding practice in a way that would "ensure learning".

Some interfaces for the application were not yet implemented nor even prototyped at the time of the campus closure. Though much of the larger interfaces had been completed and were undergoing a "touch-up" phase, there were a couple of software requests from the team's current product owner that were added to the issue queue from the last demo of the application. As the older issues began to deplete, students began to tackle these requests that needed to be added to the current system. As part of our development process, students are to paper prototype every interface before they begin any coding. Of course, given the situation, students were not able to colloborate in-person to design a prototype, an alternative had to be found. As a substitute for using paper, students were encouraged to use a wireframing tool to create mockups of the new interface they were designing. The wireframing tool proved to be more streamlined than the paper proing process because after the students got feedback on their design iterations and made redesigns based on the commentary, they were able to more quickly make design changes than they were using a paper-based methods. An added benefit of the wireframe tool was that it allowed designs to actually be responsive and perform like actual webpages (e.g., demonstrating ``onclick" events). This change in our development process ensured that the team did not stray from our prescribed software process and also introduced a tool that provides a more efficient way to prototype.

Maintaining the teams programming efficiency while also following pair programming pedagogy was critical during this time. Before COVID-19, students would sit in pairs at a workstation, alternating between driving and navigating. This particuar setup was no longer possible and it was migrated to a virtual approach. The programmers were instructed to use the communication platform to colloborate on the issues that they are working on. This meant that the students would be on a video call during the entire time that they working in order to replicate the conversation that they would have if they were next to each other. Another modification that was made was adding a plugin to the code editors used by the students, that allowed them to share their code with their partner and make edits in real-time. The student pairs were able to still swap roles so that both members of the could get time coding and analyzing the code. Furthermore, the team leads could also use this plugin to perform code reviews with the team over video call to provide more training to the team.

As exemplified above, the SSDT's software model was highly adaptable to these unprecedented conditions caused by the virus. These changes in communication, prototyping, and programming made it so that the team could maintain a similar level of productivity and efficiency as they did before COVID-19.



%Talk about Atom Teletype, Slack video calls and screen sharing, Balsamiq paper protyping, and maintaining pair programming pedagogies, daily Scrum meetings, VPNs

